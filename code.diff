diff --git a/.idea/modules.xml b/.idea/modules.xml
deleted file mode 100644
index 7b63042..0000000
--- a/.idea/modules.xml
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="ProjectModuleManager">
-    <modules>
-      <module fileurl="file://$PROJECT_DIR$/.idea/xv6.iml" filepath="$PROJECT_DIR$/.idea/xv6.iml" />
-    </modules>
-  </component>
-</project>
\ No newline at end of file
diff --git a/.idea/sshConfigs.xml b/.idea/sshConfigs.xml
index a8745f9..31b8ea8 100644
--- a/.idea/sshConfigs.xml
+++ b/.idea/sshConfigs.xml
@@ -2,7 +2,7 @@
 <project version="4">
   <component name="SshConfigs">
     <configs>
-      <sshConfig authType="PASSWORD" host="sledge.cs.ucr.edu" id="c8fddb66-b3a7-470f-9cd7-31c4e426f21a" port="22" nameFormat="DESCRIPTIVE" username="claws004" />
+      <sshConfig authType="PASSWORD" connectionConfig="{&quot;serverAliveInterval&quot;:300}" host="sledge.cs.ucr.edu" id="c8fddb66-b3a7-470f-9cd7-31c4e426f21a" port="22" nameFormat="DESCRIPTIVE" username="claws004" />
     </configs>
   </component>
 </project>
\ No newline at end of file
diff --git a/Makefile b/Makefile
index 09d790c..89df120 100644
--- a/Makefile
+++ b/Makefile
@@ -178,6 +178,8 @@ UPROGS=\
 	_rm\
 	_sh\
 	_stressfs\
+	_test\
+	_lab1\
 	_usertests\
 	_wc\
 	_zombie\
diff --git a/defs.h b/defs.h
index 82fb982..b5719c4 100644
--- a/defs.h
+++ b/defs.h
@@ -105,6 +105,7 @@ int             pipewrite(struct pipe*, char*, int);
 // proc.c
 int             cpuid(void);
 void            exit(void);
+void            exitSt(int);
 int             fork(void);
 int             growproc(int);
 int             kill(int);
@@ -120,6 +121,11 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+void            hello(void);
+void            exitSt(int);
+int             waitSt(int*);
+int             waitpid(int, int*, int);
+
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff --git a/lab1.c b/lab1.c
new file mode 100644
index 0000000..c217f36
--- /dev/null
+++ b/lab1.c
@@ -0,0 +1,25 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int waitStatus = 1;
+int exitStatus;
+int waitPidStatus = 1;
+
+int main(int argc, char *argv[]) {	
+    int pid = fork();
+    pid = waitSt(&waitStatus);
+    printf(1, "pid: %d\n", pid);
+    pid = hello();
+    if(waitpid(pid, &waitPidStatus, 0) != -1) {
+        printf(1, "waitPidStatus status: %d\n", waitPidStatus);
+    }
+    printf(1, "waitpid complete.\nwaitSt status: %d\n", waitStatus);
+
+    //exit();
+    printf(1, "\n");
+    exitSt(getpid());
+    printf(1, "exitSt status: %d\n", exitStatus);
+}
+
+
diff --git a/proc.c b/proc.c
index 806b1b1..2bb5165 100644
--- a/proc.c
+++ b/proc.c
@@ -267,6 +267,51 @@ exit(void)
   panic("zombie exit");
 }
 
+void
+exitSt(int status)
+{
+    struct proc *curproc = myproc();
+    struct proc *p;
+    int fd;
+
+    curproc->exitStatus = status;
+
+    if(curproc == initproc)
+        panic("init exiting");
+
+    // Close all open files.
+    for(fd = 0; fd < NOFILE; fd++){
+        if(curproc->ofile[fd]){
+            fileclose(curproc->ofile[fd]);
+            curproc->ofile[fd] = 0;
+        }
+    }
+
+    begin_op();
+    iput(curproc->cwd);
+    end_op();
+    curproc->cwd = 0;
+
+    acquire(&ptable.lock);
+
+    // Parent might be sleeping in wait().
+    wakeup1(curproc->parent);
+
+    // Pass abandoned children to init.
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+        if(p->parent == curproc){
+            p->parent = initproc;
+            if(p->state == ZOMBIE)
+                wakeup1(initproc);
+        }
+    }
+
+    // Jump into the scheduler, never to return.
+    curproc->state = ZOMBIE;
+    sched();
+    panic("zombie exit");
+}
+
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
 int
@@ -311,6 +356,106 @@ wait(void)
   }
 }
 
+int
+waitSt(int* status)
+{
+    struct proc *p;
+    int havekids, pid;
+    struct proc *curproc = myproc();
+
+    acquire(&ptable.lock);
+    for(;;){
+        // Scan through table looking for exited children.
+        havekids = 0;
+        for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+            if(p->parent != curproc)
+                continue;
+            havekids = 1;
+            if(p->state == ZOMBIE){
+                // Found one.
+                pid = p->pid;
+                kfree(p->kstack);
+                p->kstack = 0;
+                freevm(p->pgdir);
+                p->pid = 0;
+                p->parent = 0;
+                p->name[0] = 0;
+                p->killed = 0;
+                p->state = UNUSED;
+                if (status) {
+                    *status = p->exitStatus;
+                }
+                release(&ptable.lock);
+                return pid;
+            }
+        }
+
+        // No point waiting if we don't have any children.
+        if(!havekids || curproc->killed){
+            release(&ptable.lock);
+            if (status) {
+                *status = -1;
+            }
+            return -1;
+        }
+
+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+    }
+}
+
+int
+waitpid(int pid, int* status, int options) {
+
+    struct proc *p;
+    int found = 0;
+
+    acquire(&ptable.lock);
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+        if (p->pid != pid) {
+            continue;
+        } else {
+            found = 1;
+            break;
+        }
+    }
+
+    if (!found) {
+        release(&ptable.lock);
+        if (status) {
+            *status = -1;
+        }
+        return -1;
+    } else {
+        for (;;) {
+            if (p->state == ZOMBIE) {
+                // Found one.
+                pid = p->pid;
+                kfree(p->kstack);
+                p->kstack = 0;
+                freevm(p->pgdir);
+                p->pid = 0;
+                p->parent = 0;
+                p->name[0] = 0;
+                p->killed = 0;
+                p->state = UNUSED;
+                if (status) {
+                    *status = p->exitStatus;
+                }
+                release(&ptable.lock);
+                return pid;
+            } else if (p->state == UNUSED) {
+                if (status) {
+                    *status = p->exitStatus;
+                }
+                release(&ptable.lock);
+                return pid;
+            }
+            sleep(p, &ptable.lock);  //DOC: wait-sleep
+        }
+    }
+}
+
 //PAGEBREAK: 42
 // Per-CPU process scheduler.
 // Each CPU calls scheduler() after setting itself up.
@@ -532,3 +677,8 @@ procdump(void)
     cprintf("\n");
   }
 }
+
+void
+hello(void) {
+    cprintf("\n\n Hello from your kernel space! \n\n");
+}
\ No newline at end of file
diff --git a/proc.h b/proc.h
index 1647114..7ba52cd 100644
--- a/proc.h
+++ b/proc.h
@@ -49,6 +49,7 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int exitStatus;              // Saves exit status for a trminated process
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/syscall.c b/syscall.c
index ee85261..d61173f 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,10 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_hello(void);
+extern int sys_exitSt(void);
+extern int sys_waitSt(void);
+extern int sys_waitpid(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +130,10 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_hello]   sys_hello,
+[SYS_exitSt]  sys_exitSt,
+[SYS_waitSt]  sys_waitSt,
+[SYS_waitpid] sys_waitpid,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..79520e1 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,7 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_hello  22
+#define SYS_exitSt 23
+#define SYS_waitSt 24
+#define SYS_waitpid 25
diff --git a/sysproc.c b/sysproc.c
index 0686d29..863676e 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -89,3 +89,49 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+int
+sys_hello(void) {
+    hello();
+    return 0;
+}
+
+int
+sys_exitSt(void) {
+    int exitStatus;
+
+    if (argint(0, &exitStatus) < 0)
+        return -1;
+
+    exitSt(exitStatus);
+
+    return 0;
+}
+
+int
+sys_waitSt(void) {
+    int* exitStatus;
+
+    if (argptr(0, (char**)&exitStatus, sizeof(int*) < 0))
+        return -1;
+
+    return waitSt(exitStatus);
+}
+
+int
+sys_waitpid(void) {
+    int pid;
+    int* exitStatus;
+    int options;
+
+    if (argint(0, &pid) < 0)
+        return -1;
+
+    if (argptr(1, (char**)&exitStatus, sizeof(int*) < 0))
+        return -1;
+
+    if (argint(2, &options) < 0)
+        return -1;
+
+    return waitpid(pid, exitStatus, options);
+}
\ No newline at end of file
diff --git a/test.c b/test.c
new file mode 100644
index 0000000..ad6722e
--- /dev/null
+++ b/test.c
@@ -0,0 +1,9 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int test(int argc, char *argv[]) {
+    //printf(1, "hello world\n");
+    hello();
+    exit();
+}
\ No newline at end of file
diff --git a/user.h b/user.h
index 4f99c52..3e27041 100644
--- a/user.h
+++ b/user.h
@@ -23,6 +23,10 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int hello(void);
+int exitSt(int) __attribute__((noreturn));
+int waitSt(int*);
+int waitpid(int, int*, int);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..1e6db3b 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,7 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(hello)
+SYSCALL(exitSt)
+SYSCALL(waitSt)
+SYSCALL(waitpid)
